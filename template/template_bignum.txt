// template_bignum

const int M = 2e3 + 10;
typedef struct bigint{
    vector<int> num;
    bigint(int inum = 0) : num(M) {
        string s = to_string(inum);
        int pos = s.length() - 1;
        for(auto i : s) this->num[pos--] = i - '0';
    }
    
    bigint& operator=(const bigint& y) {
            this->num = y.num;
        return *this;
    }

    bigint operator+(const bigint& x) const {
        bigint bigsum;
        int carry = 0;
        for(int i = 0; i < M; i++) {
            int sum = this->num[i] + x.num[i] + carry;
            bigsum.num[i] = sum % 10;
            carry = sum / 10;
        }
        return bigsum;
    }

    bigint operator-(const bitint& x) const {
        bigint bigminus;
        int borrow = 0;
        for(int i = 0; i < M; i++) {
            int diff = this->num[i] - x.num[i] - borrow;
            if(diff < 0) {
                diff += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            bigminus.num[i] = diff;
        }
        return bigminus;
    }

    bigint operator*(const bigint& x) const {
        bigint bigmulti;
        int carry = 0;
        for(int i = 0; i < M; i++) {
            for(int j = 0; i + j < M; j++) {
                int sum = this->num[i] * x.num[j] + carry;
                bigmulti.num[i + j] += sum % 10;
                carry = sum / 10;
                carry += bigmulti.num[i + j] / 10;
                bigmulti.num[i + j] %= 10;
            }
        }
        return bigmulti;
    }
    bool operator<(const bigint& x) const {
        int pos1 = M - 1, pos2 = M - 1;
        while(!this->num[pos1] && pos1) pos1--;
        while(!x.num[pos2] && pos2) pos2--;
        if(pos1 != pos2) return pos1 < pos2;
        int pos = pos1;
        while(this->num[pos] == x.num[pos] && pos) pos--;
        return this->num[pos] < x.num[pos];
    }
    
    bool operator>(const bigint& x) const {
        int pos1 = M - 1, pos2 = M - 1;
        while(!this->num[pos1] && pos1) pos1--;
        while(!x.num[pos2] && pos2) pos2--;
        if(pos1 != pos2) return pos1 > pos2;
        int pos = pos1;
        while(this->num[pos] == x.num[pos] && pos) pos--;
        return this->num[pos] > x.num[pos];
    }
}bi;
istream& operator>>(istream& a, bigint& b) {
    string s;
    a >> s;
    int pos = s.length() - 1;;
    for(auto i : s) b.num[pos--] = i - '0';

    return a;
}
ostream& operator<<(ostream& a, const bigint& b) {
    int pos = M - 1;
    while(!b.num[pos] && pos) pos--;
    for(int i = pos; i >= 0; i--) {
        a << b.num[i];
    }

    return a;
}